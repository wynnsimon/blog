在分布式系统中，数据的复制和同步特别是当系统跨多个地理位置的节点时，数据一致性难以得到保障。传统的强一致性模型（如在数据库中使用的两阶段提交协议）通常会导致高延迟或低可用性，尤其是在网络断开或节点故障时。

协同编辑冲突解决：
1. 直接覆盖，后面的修改覆盖前面的修改。一个大量的修改会被被后面的修改覆盖
2. 锁机制：在编辑时锁定当前区域，其他用户无法编辑。会影响用户体验
3. 差异对比：类似git的差异对比、合并，但多个用户同时修改同一区域时纯服务端无法处理，需要客户端手动处理冲突。需要额外的操作步骤和成本，实时性很差，不适合高频同时修改的场景。
4. OT：通过操作转换来实现数据的一致性。每个用户对数据的操作（如修改、删除等）都被记录下来，并在其他用户的客户端进行相应的转换，从而实现多个用户对同一份数据的协同编辑。它可以实时地反映用户的操作，并且可以很好地处理并发冲突。然而，OT 算法需要在中心化的服务器上进行协同调度，因此对于大规模的分布式系统来说可能不太适用。
5. CRDT：

# OT
OT（Operational Transformation，操作转换），包含两个过程操作和转换。
将文档的每一次修改看作是一个操作，即操作原子化处理，如在第 N 个位置插入一个字符时，客户端会将操作发送到服务端去处理。

采用中心化的思想，由服务端统一管理文档，客户端的修改操作发送到服务端，服务端修改后将操作分发给别的客户端
客户端将原子化的操作发送到服务端时（必须有中央服务器进行调度），服务端对多个客户端的操作进行转换，对客户端操作中的并发冲突进行修正，确保当前操作同步到其他设备时得到一致的结果，因为对冲突的处理都是在服务端完成，所以客户端得到的结果一定是一致的，也就是说 OT 算法的结果**保证强一致性**。
转换完成后，通过网络发送到对应客户端，客户端合并操作，从而得到一致结果。

**示例：**
a和b同时修改一份文档，以下是初始文档
```txt
hello world
```
a在hello后面插入一个hi，消息结构如下所示
```json
{
	op:'insert',//表示当前操作为插入操作
	index:4,//表示操作开始的索引是o
	value:'hi'//表示要插入的内容
}
```
b删除了world中的l，消息结构如下所示
```json
{
	op:'delete',//表示当前操作为删除操作
	index:9,//表示操作开始的索引是l
}
```
服务端收到操作后会进行转换，比如a的操作先到达服务器
就会先应用a的修改，文档变成以下内容：
```txt
hellohi world
```
这时对于服务端接收到的操作队列的后续操作就需要做出调整了，将b的操作消息更改成以下内容
```json
{
	op:'delete',//表示当前操作为删除操作
	index:11,//表示操作开始的索引是l
}
```
OT 算法会通过一系列的变化来调整其中一个操作，而这个调整转化的核心就是transform方法，通过操作到达的时间顺序，对不同的操作进行修正，最终得到一致的结果。
缺点：OT 算法对网络要求更高，如果某个用户出现网络异常，导致一些操作缺失或延迟，那么服务端的转换就会出现问题。

# CRDT

CRDT（Conflict-free Replicated Data Type，无冲突复制数据类型），是一种基于数据结构的无冲突复制数据类型算法，它通过数据结构的合并来实现数据的一致性。
在 CRDT 算法中，每个用户对数据的修改都会被记录下来，并在其他用户的客户端进行合并，以实现数据的一致性。CRDT 算法的优点在于它可以适用于大规模的分布式系统，并且不需要中心化的服务器进行协同调度。但是，CRDT 算法在处理复杂操作时可能会存在合并冲突的问题，需要设计复杂的合并函数来解决。

CRDT有两种实现方式：
- CmRDT：基于操作的 CRDT（OP-based-CRDT）：容易设计和实现，每个 CRDT 的整个状态最终都必须传输给其他每个副本，每个副本之间通过同步全量状态达到最终一致状态，开销很大；
- CvRDT：基于状态的 CRDT，（State-based CRDT）：基于操作的 CRDT 只传输更新操作，各副本之间通过同步操作来达到最终一致状态，通常很小。

## CmRDT








