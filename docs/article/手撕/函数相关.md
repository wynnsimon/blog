---
title: 函数相关
tags:
  - 手撕
  - 前端
permalink: /article/shred/1/
createTime: 2025/08/21 22:17:25
---

# call

```js
Function.prototype.myCall = function (context, ...args) {
  const fn = Symbol("fn");
  context[fn] = this;
  const res = context[fn](...args);
  delete context[fn];
  return res;
};

```

# apply
```js
Function.prototype.myApply = function (context, args) {
  const fn = Symbol("fn");
  context[fn] = this;
  const res = context[fn](...args);
  delete context[fn];
  return res;
};
```

# bind
```js
Function.prototype.myBind = function (context, ...args) {
  return (...reArgs) => {
    return this.myCall(context, ...args, ...reArgs);
  };
};
```

# 函数柯里化

## 实现一个能将一个函数柯里化的函数
```js
/**
 * 柯里化一个函数
 * @param {*} fn 要柯里化的函数
 * @param  {...any} args 传入的参数
 */
function curry(fn, ...args) {
  if (args.length >= fn.length) {
    // 如果参数足够，则直接调用函数返回结果
    return fn(...args);
  } else {
    // 否则，返回一个函数，等待剩余参数的传入
    return (...rest) => {
      return curry(fn, ...args, ...rest);
    };
  }
}
```

## 实现一个可以传递任意长度参数以及任意调用次数的柯里化求和函数
```js
/**
 * 柯里化求和函数，如果要获取值需要手动调用toString方法，否则返回的是柯里化函数
 * 可以接受任意长度的参数，以及调用任意次
 * @returns 柯里化剩余函数
 */
function curryAdd() {
  // 保存首次调用的参数
  let args = [...arguments];
  // 柯里化剩余函数
  const inner = function () {
    args.push(...arguments);
    return inner;
  };
  // 获取值的函数
  inner.getValue = function () {
    return args.reduce((a, b) => a + b);
  };
  // 返回柯里化剩余函数
  return inner;
}
```

