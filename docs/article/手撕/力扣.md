---
title: 力扣
createTime: 2025/09/03 18:13:14
permalink: /article/shred/8/
---

# 3 无重复字符的最长字串

[3. 无重复字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)

滑动窗口实现
```js
function lengthOfLongestSubstring(s) {
	// 记录最大长度
  let maxLen = 0;
  // 当前窗口中的元素
  const temp = [];
  for (let right = 0; right < s.length; ++right) {
    // 只要当前窗口中有最新的元素就出队一个元素
    while (temp.includes(s[right])) {
      temp.shift();
    }
    // 入队最新的元素
    temp.push(s[right]);
    // 如果最大长度小于当前元素的长度就覆盖
    if (maxLen < temp.length) {
      maxLen = temp.length;
    }
  }
  return maxLen;
}
```

# LRU

[146. LRU 缓存 - 力扣（LeetCode）](https://leetcode.cn/problems/lru-cache/)

使用map做缓存，调用get时如果元素存在就删除后再添加进去
```js
class LRU {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }

  get(key) {
    if (this.cache.has(key)) {
      const value = this.cache.get(key);
      this.cache.delete(key);
      this.cache.set(key, value);
      return value;
    } else {
      return -1;
    }
  }

  put(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else {
      if (this.cache.size >= this.capacity) {
        const oldestKey = this.cache.keys().next().value;
        this.cache.delete(oldestKey);
      }
    }
    this.cache.set(key, value);
  }
}
```

# 反转链表

[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/description/)

双指针，在反转时需要构造一个temp做中转
```js
class ListNode {
  constructor(val, next) {
    this.val = val === undefined ? 0 : val;
    this.next = next === undefined ? null : next;
  }
}

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
function reverseList(head) {
  let cur = head;
  let pre = null;

  while (cur) {
    const temp = cur.next;
    cur.next = pre;
    pre = cur;
    cur = temp;
  }
  return pre;
}
```

# 比较版本号

[165. 比较版本号 - 力扣（LeetCode）](https://leetcode.cn/problems/compare-version-numbers/description/)

切割字符串并转换成数字类型
还可以使用生成器返回迭代器的方式优化性能
```js
/**
 * @param {string} version1
 * @param {string} version2
 * @return {number}
 */
function compareVersion(version1, version2) {
  const arr1 = version1.split(".");
  const arr2 = version2.split(".");
  while (arr1.length && arr2.length) {
    const v1 = parseInt(arr1.shift());
    const v2 = parseInt(arr2.shift());
    if (v1 > v2) return 1;
    if (v1 < v2) return -1;
  }
  if (arr1.length) {
    return arr1.every((v) => v == 0) ? 0 : 1;
  }
  if (arr2.length) {
    return arr2.every((v) => v == 0) ? 0 : -1;
  }
  return 0;
}
```

# 合并两个有序数组

[88. 合并两个有序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-sorted-array/)

三指针从后往前遍历，避免数据覆盖。
```js
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
function merge(nums1, m, nums2, n) {
  let i = m - 1;
  let j = n - 1;
  let k = m + n - 1;

  while (i >= 0 && j >= 0) {
    nums1[k--] = nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];
  }
  while (i >= 0) {
    nums1[k--] = nums1[i--];
  }
  while (j >= 0) {
    nums1[k--] = nums2[j--];
  }
}
```






