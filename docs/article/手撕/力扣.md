---
title: 力扣
createTime: 2025/09/03 18:13:14
permalink: /article/shred/8/
---

# 3 无重复字符的最长字串

[3. 无重复字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)

滑动窗口实现
```js
function lengthOfLongestSubstring(s) {
	// 记录最大长度
  let maxLen = 0;
  // 当前窗口中的元素
  const temp = [];
  for (let right = 0; right < s.length; ++right) {
    // 只要当前窗口中有最新的元素就出队一个元素
    while (temp.includes(s[right])) {
      temp.shift();
    }
    // 入队最新的元素
    temp.push(s[right]);
    // 如果最大长度小于当前元素的长度就覆盖
    if (maxLen < temp.length) {
      maxLen = temp.length;
    }
  }
  return maxLen;
}
```

# LRU

[146. LRU 缓存 - 力扣（LeetCode）](https://leetcode.cn/problems/lru-cache/)

使用map做缓存，调用get时如果元素存在就删除后再添加进去
```js
class LRU {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }

  get(key) {
    if (this.cache.has(key)) {
      const value = this.cache.get(key);
      this.cache.delete(key);
      this.cache.set(key, value);
      return value;
    } else {
      return -1;
    }
  }

  put(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else {
      if (this.cache.size >= this.capacity) {
        const oldestKey = this.cache.keys().next().value;
        this.cache.delete(oldestKey);
      }
    }
    this.cache.set(key, value);
  }
}
```

# 反转链表

[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/description/)

双指针，在反转时需要构造一个temp做中转
```js
class ListNode {
  constructor(val, next) {
    this.val = val === undefined ? 0 : val;
    this.next = next === undefined ? null : next;
  }
}

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
function reverseList(head) {
  let cur = head;
  let pre = null;

  while (cur) {
    const temp = cur.next;
    cur.next = pre;
    pre = cur;
    cur = temp;
  }
  return pre;
}
```

# 比较版本号

[165. 比较版本号 - 力扣（LeetCode）](https://leetcode.cn/problems/compare-version-numbers/description/)

切割字符串并转换成数字类型
还可以使用生成器返回迭代器的方式优化性能
```js
/**
 * @param {string} version1
 * @param {string} version2
 * @return {number}
 */
function compareVersion(version1, version2) {
  const arr1 = version1.split(".");
  const arr2 = version2.split(".");
  while (arr1.length && arr2.length) {
    const v1 = parseInt(arr1.shift());
    const v2 = parseInt(arr2.shift());
    if (v1 > v2) return 1;
    if (v1 < v2) return -1;
  }
  if (arr1.length) {
    return arr1.every((v) => v == 0) ? 0 : 1;
  }
  if (arr2.length) {
    return arr2.every((v) => v == 0) ? 0 : -1;
  }
  return 0;
}
```

# 合并两个有序数组

[88. 合并两个有序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-sorted-array/)

三指针从后往前遍历，避免数据覆盖。
```js
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
function merge(nums1, m, nums2, n) {
  let i = m - 1;
  let j = n - 1;
  let k = m + n - 1;

  while (i >= 0 && j >= 0) {
    nums1[k--] = nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];
  }
  while (i >= 0) {
    nums1[k--] = nums1[i--];
  }
  while (j >= 0) {
    nums1[k--] = nums2[j--];
  }
}
```

# 字符串相加

[415. 字符串相加 - 力扣（LeetCode）](https://leetcode.cn/problems/add-strings/description/)
从后往前遍历字符串，将字符转换成数字相加
也可以在位数不足的前面补上0
```js
/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
var addStrings = function (num1, num2) {
  let result = "";
  let i = Math.max(num1.length, num2.length);
  let j = 1;
  let carry = 0;
  while (j <= i) {
    const n1 = num1[num1.length - j] ? parseInt(num1[num1.length - j]) : 0;
    const n2 = num2[num2.length - j] ? parseInt(num2[num2.length - j]) : 0;
    const sum = n1 + n2 + carry;
    const res = sum % 10;
    carry = Math.floor(sum / 10);
    result = res + result;

    ++j;
  }
  if (carry) {
    result = carry + result;
  }
  return result;
};
```

# 有效括号

[20. 有效的括号 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-parentheses/)

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function (s) {
  const stack = [];
  for (let i = 0; i < s.length; ++i) {
    if (["(", "[", "{"].includes(s[i])) {
      stack.push(s[i]);
    } else if (["}", "]", ")"].includes(s[i])) {
      if (stack.length === 0) {
        return false;
      } else {
        const top = stack.pop();
        if (
          (top === "(" && s[i] === ")") ||
          (top === "[" && s[i] === "]") ||
          (top === "{" && s[i] === "}")
        ) {
          continue;
        }
        return false;
      }
    }
  }
  return stack.length === 0;
};
```

# 两数之和

[1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/)

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function (nums, target) {
  for (let i = 0; i < nums.length; ++i) {
    for (let j = i + 1; j < nums.length; ++j) {
      if(nums[i] + nums[j] === target){
        return [i, j];
      }
    }
  }
};
```

# 全排列

[46. 全排列 - 力扣（LeetCode）](https://leetcode.cn/problems/permutations/description/)

回溯：有状态的递归

使用回溯法
递归进行深搜，遍历数字数组，如果当前元素存在于状态数组中表示当前元素已经在结果数组中了就跳过，如果不在就添加入状态数组中，继续递归，当递归出来后将当前元素从状态数组中取出（修改状态）

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function (nums) {
  const result = [];
  function bfs(arr) {
    if (arr.length === nums.length) {
	    // 防止引用传递
      result.push(JSON.parse(JSON.stringify(arr)));
      return;
    } else {
      for (let i = 0; i < nums.length; ++i) {
        if (arr.includes(nums[i])) {
          continue;
        } else {
          arr.push(nums[i]);
          bfs(arr);
          arr.pop();
        }
      }
    }
  }
  bfs([]);
  return result;
};
```
