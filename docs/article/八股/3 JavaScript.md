---
title: 3 JavaScript
tags:
  - 八股
  - 前端
  - JavaScript
createTime: 2025/06/17 18:14:20
permalink: /article/essay/3/
---

# \=\=和\=\=\=
（\=\=）在比较中会先进行类型转换，再确定操作数是否相等
（ === ）只有两个操作数在不转换的前提下相等才返回 `true`。即类型相同，值也需相同


# JavaScript的组成
#### JavaScript的组成
- ECMAScrip：JavaScript的语法标准，规定了基本语法、数据类型、操作符等。
- BOM（浏览器对象模型）：提供与浏览器交互的接口，如`window`、`location`、`navigator`等。
- DOM（文档对象模型）：将HTML文档表示为树形结构，提供操作文档的接口。

#### BOM的API
- `window`：全局对象，提供与窗口相关的操作，如`window.alert()`、`window.location`等。
- `location`：提供当前页面的URL信息，如`location.href`、`location.reload()`等。
- `navigator`：提供浏览器信息，如`navigator.userAgent`。

#### DOM的API
- `document`：代表整个HTML文档，提供查找和操作元素的方法，如`document.getElementById()`、`document.createElement()`等。
提供操作元素属性、样式、事件等方法。

#### Cookie
- 存储位置：属于DOM，通过`document.cookie`提供了一种方式来访问由浏览器为当前网页管理的cookie，这更接近于浏览器的行为层面，即BOM的部分功能。因为从根本上说，cookie的管理和存储是由浏览器控制的，
- 用途：存储用户身份信息、会话状态等。

# for in和for of
### for in
用于**遍历对象的可枚举属性名（键）**。
- 遍历的是对象的 **键（key）**。
- 可以遍历普通对象、数组、字符串等所有可枚举属性。
- 不保证顺序（尤其在对象中），不建议用于遍历数组（顺序可能不符合预期）。
- 包括原型链上的可枚举属性（除非使用 `hasOwnProperty()` 判断）。

### for of
用于**遍历可迭代对象的值（value）**。
- 遍历的是 **值（value）**。
- 支持的类型包括：`Array`、`Map`、`Set`、`String`、`TypedArray`、`arguments` 对象、生成器（Generator）等。
- 不适用于普通对象（因为普通对象不可迭代）。
- 顺序是可预测的（如数组按索引顺序遍历）。

# 事件委托

事件委托（Event Delegation） 是 JavaScript 中一种高效的事件处理机制，它利用了 事件冒泡 的特性，将事件监听器绑定到父元素上，而不是每个子元素单独绑定。

### 事件委托的原理
- 在 DOM 中，事件会从目标元素向上传播（冒泡），途中经过它的所有祖先节点。
- 利用这一特性，我们可以在父级元素统一监听事件然后根据事件对象中的 `target` 属性判断具体是哪个子元素触发了事件。
### 事件委托的优点
1. 性能优化
    - 减少绑定的事件监听器数量，尤其适用于动态内容或大量子元素。
2. 支持动态添加的元素
    - 不需要为新添加的子元素重新绑定事件监听器。
3. 代码更简洁、易维护
    - 更少的事件绑定逻辑，提升可维护性。

**事件委托就是“以父治子”，通过父元素来管理子元素的事件，提高性能和灵活性。**

|方式|优点|缺点|
|---|---|---|
|直接绑定事件|逻辑清晰，控制粒度细|性能差，不易维护动态内容|
|事件委托|性能好，兼容动态内容|逻辑稍复杂，需判断事件源|

# 事件冒泡

事件冒泡 是 JavaScript 中 事件传播机制的一部分，它指的是：当一个元素上的事件被触发时，该事件会从当前元素（目标元素）开始，向上传播到其父元素、祖父元素，一直到 `window` 对象。

### 事件冒泡的应用
- 事件委托：利用冒泡机制，在父元素监听子元素的事件。
- 统一处理嵌套结构中的交互逻辑
- 阻止冒泡：使用 `event.stopPropagation()` 来阻止事件继续向上传播。

| 特性   | 事件捕获（Capture Phase）                | 事件冒泡（Bubbling Phase）                         |
| ---- | ---------------------------------- | -------------------------------------------- |
| 执行顺序 | 从外层向内层（window → target）            | 从内层向外层（target → window）                      |
| 默认行为 | 否                                  | 是                                            |
| 是否支持 | 支持                                 | 支持                                           |
| 使用方式 | `addEventListener(type, fn, true)` | `addEventListener(type, fn, false)` 或不写第三个参数 |

# this的指向
谁调用指向谁
全局环境下的this指向window

箭头函数：没有this和arguments，捕捉外层的执行环境，继承了该外层的this

# 两个对象如何比较
1. 使用JSON.stringifyO方法转化成json字符串比较
2. 使用es6的object.is0方法
3. 使用递归的方式

# 展开运算符
迭代的对象展开到单独的元素中

对一维数组深拷贝
对多维数组第，一维深拷贝，其它为浅拷贝
对象的拷贝：一层深拷贝，二层浅拷贝

# console.log
在打印一个数组或对象时，我们在控制台看到的是他的最终状态而不是打印时的庄状态
因为对于这些复杂数据类型，打印的是指向对象的引用，当在控制台展开对象时就会执行get函数获取对象的值，而此时对象的数据已经改变
在打印数组或对象时最好使用`JSON.stringify`打印或者打印其中具体的值这样就能得到打印时的值了

