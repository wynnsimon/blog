---
title: 浏览器
tags:
  - 八股
  - 前端
  - 浏览器
createTime: 2025/06/18 11:00:46
permalink: /article/essay/6/
---
# JWT的全部流程及作用

### 全部流程
1. **用户登录**
 用户在客户端输入用户名和密码，客户端将这些信息发送到服务器。
2. **服务器验证**
服务器收到登录请求后，验证用户凭据。验证通过后，服务器生成一个JWT。
3. **生成JWT**
   - 头部（Header）：包含令牌类型和签名算法
   - 载荷（Payload）：包含用户信息，如用户ID、角色、过期时间等
   - 签名（Signature）：服务器使用密钥对头部和载荷进行签名，确保数据完整性。
2. **返回JWT**
服务器将生成的JWT返回给客户端。
3. **客户端存储JWT**
客户端收到JWT后，通常存储在`localStorage`、`sessionStorage`或Cookie中。
4. **后续请求**
客户端在每次请求受保护的资源时，将JWT放在HTTP请求的`Authorization`头部中，格式为`Bearer <JWT>`。
5. **服务器验证JWT**
服务器收到请求后，验证JWT的签名和有效期。验证通过后，从载荷中获取用户信息，授权访问资源。

### 作用

1. 身份认证
通过JWT确认用户身份，无需每次请求都查询数据库。
2. 无状态性
服务器不需要存储用户状态，减轻负担，易于扩展。
3. 跨域支持
适用于前后端分离和分布式系统。
4. 安全性
使用签名算法，确保数据在传输过程中不被篡改。
5. 信息传递
可以在载荷中携带少量业务信息，减少数据库查询。

# 协商缓存和强制缓存

## 协商缓存
浏览器在请求资源时会发送请求和资源的标识，服务器收到请求和资源标识后判断该资源是否为最新资源，如果不是则返回200状态码以及最新的资源和新的标识，浏览器收到后会将资源缓存在本地缓存中，后续再次请求时依旧带有新的资源标识，如果服务器判断该资源标识是最新资源则会返回304状态码，不携带任何资源，浏览器收到304响应后会直接从本地缓存中拿资源
![](attachments/Pasted%20image%2020250728205155.png)
协商缓存相关的请求头字段：
Last-Modified和If-Modified-Since共用
- Last-Modified: GMT时间：最后被修改的时间，是一个GMT时间类型
- If-Modified-Since: GMT时间：和Last-Modifed对比查看是否有更新
ETag和If-None-Match共用
- ETag：可以存任意类型的数据，用于后端自己对比，如：版本号、哈希值等
- If-None-Match: 和ETag一样格式的数据，用于和ETag对比判断是否有更新
如果Last-Modified和ETag并存，会优先使用ETag

## 强制缓存
当浏览器向服务器拿资源时，服务器会将它认为需要缓存的资源（通常是cs，js，图片等）在头部加上cache-control字段max-age标识生效时间，标识出该资源需要缓存，和缓存生效的时间，浏览器收到响应后会把资源存储在本地的缓存中，后续再次请求该资源时会先去本地缓存检查是否有该资源以及时间是否过期，如果有该资源且没有过期就会直接从本地缓存中拿资源，返回的状态码是：200（from memory cache）
强制缓存的过程中前端不需要做任何处理
![](attachments/Pasted%20image%2020250728205218.png)
强制缓存相关的请求头字段：
- Cache-Control: max-age=秒数：设置缓存的时间秒数
- Expire: GMT时间：设置缓存过期的时间，GMT时间类型
两个字段并存的情况下Cache-Control优先级更高

缓存会存在硬盘或内存。相应的浏览器调试工具中也会在后面标注from disk cache或from memory cache

# cookie、session、token

## cookie
用户登录时将用户名和密码发送给服务器，服务器接收到验证成功后会将用户名存储在set-cookie的请求头发送给浏览器，同时记录该用户的登录状态，浏览器收到响应携带的用户名时会将其存储在cookie中，后续的请求都会携带cookie

1. 存储在客户端
2. 帮助在客户端和服务器之间维护状态信息
3. 安全风险：有被串改风险
4. 容量限制：4KB
5. 可用限制：用户可能禁用

## session
session是存储在服务器的
用户登录后服务器会根据用户的信息生成sessionid，并将其放在响应头的set-cookie字段中，浏览器收到响应后会将sessionid存储在cookie中，后续的每次发送请求都会携带sessionid，服务器会对其进行校验

用户拿不到其中的用户信息

1. 安全性高：存储在服务器端
2. 容量大：可以保存对象
3. 占用服务器资源
4. 扩展性差（分布式集群）
5. 依然需要依赖cookie跨域限制

## token
jwt分为三段，分别是header（算法和token类型）、payload（数据载荷）、signature（header+payload+私钥通过header中指定的算法来加密）
用户可以拿到token通过截取第二段解密来拿到用户数据，但是无法修改

用户登录后服务器进行校验，鉴权成功就会创建jwt令牌，发送给用户，用户拿到token后可以截取第二段并通过base64解码就可以拿到用户信息，但无法修改，后续在使用时可以将token存储在与后端约定的请求头属性（通常是Authorization）发送给后端，后端收到请求时会验证token有没有被篡改，如果没有被篡改就会进行放行

后端是可以解析tokne的，私钥可以被任何集群服务器知晓，来验证

cookie 用户存储账号和密码
session 服务器存储账户和密码
token 传输对象存储账户和密码

| 特性              | `localStorage`      | `sessionStorage`      | `cookie`                  |
| --------------- | ------------------- | --------------------- | ------------------------- |
| **生命周期**        | 永久保存（除非手动清除）        | 页面会话期间有效（关闭页面/标签页后清除） | 可以设置过期时间，默认是会话级别          |
| **作用域**         | 同源（同协议 + 同域名 + 同端口） | 同源且同一窗口/标签页           | 同域名及路径下可访问                |
| **是否随请求发送到服务器** | 不会自动发送              | 不会自动发送                | 默认每次请求都会携带                |
| **存储容量**        | 约 5MB~10MB          | 约 5MB~10MB            | 单个 cookie 约 4KB，总量受限制     |
| **操作方式**        | JavaScript API      | JavaScript API        | JavaScript 或 HTTP headers |
| **安全性**         | 易受 XSS 攻击           | 易受 XSS 攻击             | 可被设置为 `HttpOnly` 防止 XSS   |
| **应用场景**        | 用户偏好、本地缓存等          | 临时数据、页面间通信            | 身份验证、服务端状态管理              |

# Token过期时的处理

#### 1. 重新登录

**适用场景**：最简单直接的方式，适用于Token完全失效且无法刷新的情况。
**处理步骤**：
- 检测到Token过期后，清除本地存储的Token。
- 跳转到登录页面，提示用户重新输入凭据进行登录。
- 登录成功后，获取新的Token并继续之前的操作。

#### 2. 使用刷新Token机制

**适用场景**：提升用户体验，避免频繁重新登录。
**处理步骤**：
- **登录时获取Access Token和Refresh Token**：
    用户登录成功后，服务器返回一个短期有效的Access Token和一个长期有效的Refresh Token。
- **请求时携带Access Token**：
    每次发送请求时，在请求头中携带Access Token进行身份验证。
- **检测到Access Token过期**：
    在响应拦截器中捕获返回的Token过期错误（如HTTP状态码401或特定的错误信息）。
- **使用Refresh Token获取新Token**：
    如果检测到Access Token过期，使用Refresh Token向服务器请求新的Access Token。
    服务器验证Refresh Token的有效性，若有效，返回新的Access Token。
- **更新并继续请求**：
    更新本地存储的Access Token。
    重新发送之前因Token过期而失败的请求。
- **处理Refresh Token过期**：
    如果Refresh Token也过期，清除所有Token，引导用户重新登录。

#### 3. 滑动窗口机制
**适用场景**：用户持续活跃的情况下，保持Token的有效性。
**处理步骤**：
- 服务器在每次验证Token有效时，自动延长Token的过期时间。
- 只要用户持续访问，Token就会一直有效，无需重新登录或刷新。

#### 4. 前端检测与处理
**设置Token过期时间**：
- 在获取Token时，记录其过期时间。
- 在发送请求前，检查Token是否即将过期。
**自动刷新Token**：
- 如果Token即将过期，在用户无感知的情况下自动使用Refresh Token刷新Access Token。

#### 5. 优化用户体验
**友好提示**：
- 在Token即将过期时，弹出提示框提醒用户。
- 避免直接中断用户操作，提供继续操作的选项。
**无缝切换**：
- 在刷新Token期间，保持页面状态，避免页面跳转或刷新。

#### 6. 安全考虑
**保护Refresh Token**：
- 将Refresh Token存储在安全的本地存储中，避免存储在Cookie或容易被篡改的位置。
- 使用HTTPS协议传输敏感信息。
**防止重复刷新**：
- 在刷新Token时，设置标志位防止多次重复请求。
- 处理并发请求，避免因Token过期导致的混乱。

#### 7. 日志与监控
**记录Token状态**：
- 记录Token的生成、使用和过期情况。
- 监控Token的有效期和刷新频率，及时发现潜在问题。

通过以上方法，可以有效处理Token过期的情况，提升系统的安全性和用户体验。具体采用哪种方式，应根据业务需求和实际情况进行选择。

# 在window对象上绑定数据的的题
1. 命名冲实
后绑定的重名数据系把前面的覆盖
2. 安全风险
任何人可以获取和修改。
3. 性能问题，
占用的存如果不解绑也不会清除
4. 全局污染
任何人都可以获取到也可以修改

解决：模块化、命名空间、IIFE、开启严格模式、qiankun代理沙箱

# 地址栏输入url回车后发生了什么

### 1. url检测：纠错、补全、转换
检测url是否有误
如果没有带协议会补全协议
根据协议补全端口（http：80，https：443）
如果不是网址，是个关键词会使用搜索引擎加上关键词在搜索引擎中搜索
如果url中有中文等非ascii字符的话还会转换为ascii码

### 2. DNS解析
根据url地址先查看浏览器dns缓存，再查找本地dns缓存，再查找本地hosts文件如果缓存命中则直接访问网址
如果缓存不命中则向域名服务器发送请求

dns解析要经过的服务器：
1. 客户端
2. 本地dns服务器
3. 权威域名服务器
4. 顶级域名服务器
5. 根域名服务器

查找方式有两种：
1. 客户端向本地dns服务器发送请求，本地dns服务器分别向权威、顶级、根等域名服务器发送请求来查询。对本地dns服务器压力过大
2. 递归查询，本地dns服务器向权威域名服务器发送请求，如果权威没查找到就向顶级发送查找请求，依次类推分别向自己的上级发送查找请求，找到后再返回给自己的下级


### 3. 建立tcp连接

![](attachments/Pasted%20image%2020250728205037.png)
如果使用的是https协议还会再进行SSL握手，建立加密信道。使用SSL握手时，会确定是否使用了http2

### 4. 浏览器自动发送请求
浏览器决定要附带哪些cookie到请求头中
浏览器自动设置好请求头、协议版本、cookie，发出GET请求

### 5. 服务器处理数据并响应
服务器处理请求，进入后端处理流程。完成处理后，服务器响应一个HTTP报文给浏览器。

### 6. 浏览器决定是否保留连接
浏览器根据使用的协议版本，以及Connection字段的约定，决定是否要保留TCP连接

如果不需要保留会进行tcp四次挥手

### 7. 解析状态
根据响应状态码决定如何处理该请求

### 8. 解析响应头
浏览器根据响应头中的Content-Type字段识别响应类型，比如：html、css、js、图片等资源会做不同的处理

接着会根据请求头中的设置的缓存、cookie等做处理

### 9. 解析响应体
浏览器开始从上到下解析响应体的内容
如：解析HTML，若遇到外部资源链接，则进一步请求资源

### 10. 浏览器渲染过程
参照浏览器渲染原理

# CSRF攻击
CSRF （Cross-site request forgery，跨站请求伪造）
攻击者利用了用户的身份信息，执行了用户非本意的操作

用户在请求正常的网站时会获取到cookie并保存在本地，后续再次请求该网站就把对应网站的cookie携带过去。
危险网站中的某个资源的链接（不用js执行请求是因为有跨域问题）指向要攻击的网站的请求以及设置请求头中携带的参数（因为是get请求只能使用请求头传参）。用户访问到危险网址时页面渲染到该元素就会发送请求，访问要攻击的网站，而在访问的时候用户本地存有cookie就会携带用户的cookie，而服务器就会误以为是用户在操作
![](attachments/Pasted%20image%2020250706140331.png)

### 防御方式

1. 不使用cookie
防御力高，兼容性略差。ssr会遇到困难，但可解决

2. 使用sameSite
防御力较高。兼容性差。容易挡住自己人

即使将敏感操作使用post请求也还是可以攻击到：
在页面中放一个表单，表单中填入网站和参数，使用表单也是可以发送post请求的。但是这样会跳转到目标页面，用户会看到，可以使用iframe标签包裹，这样只会在iframe标签中跳转，将iframe标签设为不可见用户就看不到了

sameSite是一个请求头的字段，该字段有三个取值：
- none：无作用
- sameSite-Strict：严格模式，只有源网站和请求的网址都一致（和cookie所属的网站一致）才会携带cookie。但这样会阻挡其他正常网站的访问
- sameSite-Lax：只有get请求才会携带cookie，post请求不会携带cookie

3. csrf token
防御力高，获取到token后未进行操作仍然会被攻击

用户请求服务器时，服务器会生成一个随机的token发送给用户（只有通过自己的网站访问才会使用这个token），且该token只能使用一次，并将该token保存在服务器上。当用户进行操作时会携带该token。如果不是自己的网站会使用保存的token就无法通过验证。使用后这个token就失效了

但用户获取到一次性toeken后再次发送请求还没有到达服务器，而在这期间又访问了危险网址，危险网站的请求先自己的请求到达服务器就也无法成功防护

4. referer防护
防御力低，过去很常用，现在已经发现漏洞

请求头中携带referer字段（和origin字段很像都保存请求的源网站），如果referer的源网址不在服务器的白名单内就拒绝访问

但是将恶意代码使用base64编码后可以绕过

# XSS攻击
XSS（Cross Site Scripting，跨站脚本攻击），攻击者利用站点的漏洞，表单提交
时，在表单内容中加入一些恶意脚本，当其他正常用户浏览页面，而页面中刚好出现攻击者的恶意脚本时，脚本被执行，从而使得页面遭到破坏，或者用户信息被窃取。
![](attachments/Pasted%20image%2020250706144746.png)
攻击者在正常的网址中发布所有人都可以访问的内容，如：文章。在写文章时在里面加入script等危险的标签，并在里面设置脚本代码。将该文件提交给服务器，服务器保存下来。正常用户访问时就会将这些内容发送给用户，用户浏览器渲染时就会将script标签中包裹的脚本执行

### 防御方式
服务器端对用户提交的内容进行过滤或编码
- 过滤：去掉一些危险的标签，去掉一些危险的属性
由于前端如果过滤的话还有可能被篡改，或者发送未经过滤的标签，所以还需要后端处理。与其处理两次不如直接让后端处理
- 编码：标签进行HTML实体编码
```
&lt;srcipt&gt;...&lt;/script&gt;
```
编码后浏览器就不会识别成srcipt标签了，而是直接当成文本展现

# 网络性能优化
- 优化打包体积
利用一些工具压缩、混淆最终打包代码，减少包体积
- 多目标打包
利用一些打包插件，针对不同的浏览器打包出不同的兼容性版本，这样一来，每个版本中的兼容性代码就会大大减少，从而减少包体积
- 压缩
现代浏览器普遍支持压缩格式，因此服务端的各种文件可以压缩后再响应给客户端，只要解压时间小于优化的传输时间，压缩就是可行的
- CDN
利用CDN可以大幅缩减静态资源的访问时间，特别是对于公共库的访问，可以使用知名的CDN资源，这样可以实现跨越站点的缓存
- 缓存
对于除HTML外的所有静态资源均可以开启协商缓存，利用构建工具打包产生的文件hash值来置换缓存
- http2
开启http2后，利用其多路复用、头部压缩等特点，充分利用带宽传递大量的文件数据
- 雪碧图
对于不使用HTTP2的场景，可以将多个图片合并为雪碧图，以达到减少文件的目的
- defer、async
通过defer和async属性，可以让页面尽早加载js文件
- prefetch、preload
通过prefetch属性，可以让页面在空闲时预先下载其他页面可能要用到的资源
通过preload属性，可以让页面预先下载本页面可能要用到的资源
- 多个静态资源域
将相对独立的静态资源分到多个域中保存，可以让浏览器同时开启多个TCP连接，并行下载

# WebSocket

## 短轮询
每隔一段时间就给服务器发送一下请求，服务器收到后响应结果
![](attachments/Pasted%20image%2020250706162420.png)
**缺点：**
- 会产生大量无意义的请求
- 会频打开关闭连接

## 长轮询
服务器收到请求后会先不响应，等一段时间后查看是否有结果，如果有结果就响应给客户端，客户端可能拿到结果。如果没结果就返回没有结果的响应，客户端收到后就会进行下一次轮询
![](attachments/Pasted%20image%2020250706162541.png)
长轮询有效的解决了话痨问题」，让每一次请求和响应都是有意义的

**缺点：**
- 客户端长时间收不到购应会会导致超时，从而主动断开和服务器的连接
这种情况是可以处理的，但ajax请求因为超时而结束时，立即重新发送请求到服务器。虽然这种做法会让之前的请求变得无意义，但毕竟比短轮询好多了
- 由于客户端可能「过早的」请求了服务器，服务器不得不挂起这个请求直到新消息的出现。这会让服务器长时间的占用资源却没什么实际的事情可做

## WebSocket
WebSocket也是建立在TCP协议之上的，利用的是TCP全双工通信的能力
使用WebSocket，会经历两个阶段：握手阶段、通信阶段

虽然优于轮询方案，但WebSocket仍然是有缺点的：
- 兼容性
WebSocket是HTML5新增的内容，因此古董版本的浏览器并不支持
- 维持TCP连接需要耗费资源
对于那些消息量少的场景，维持TCP连接确实会造成资源的浪费

当客户端需要和服务器使用WebSocket进行通信时，首先会使用HTTP协议完成一次特殊的请求-响应，这一次请求-响应就是WebSocket握手

1. 创建连接
```js
let ws=new WebSocket('ws://localhost:8080')
```

2. 设置回调函数
```js
ws.onopen=()=>{
	// 连接成功触发
}

ws.onmessage=(e)=>{
	// 收到服务器的消息后触发
}

ws.onclose=()=>{
	// 连接关闭后触发
}
```

3. 发送消息
```js
ws.send('msg')
```

实例的readyState属性可以获取到连接状态
- 0：正在连接
- 1：已连接
- 2：正在关闭
- 3：已关闭

# npm安装机制
1. npm会检查本地的node_modules目录中是否已经安装过该模块，如果已经安装，则不再重新安装
2. npm检查缓存中是否有相同的模块，如果有，直接从缓存中读取安装
3. 如果本地和缓存中均不存在，npm会从registry指定的地址下载安装包，然后将其写入到本地的node_modules目录中，同时缓存起来。
