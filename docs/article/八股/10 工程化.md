---
title: 10 工程化
tags:
  - 原理
  - 前端
  - 工程化
createTime: 2025/06/29 12:19:22
permalink: /article/essay/10/
---
# vite
bundleless少打包或者不打包
esm有了浏览器的支持才有bundleless方案

webpack会先打包，然后启动开发服务器，请求服务器时直接给予打包结果。

而vite是直接启动开发服务器，请求哪个模块再对该模块进行实时编译。
由于现代浏览器本身就支持ESModule，会自动向依赖的Module发出请求。vite充分利用这一点，将开发环境下的模块文件，就作为浏览器要执行的文件，而不是像webpack那样进行打包合并。
由于vite在启动的时候不需要打包，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。
当浏览器请求某个模块时，再根据需要对模块内容进行编译。这种按需动态编译的方式，极大的缩减了编译
时间，项目越复杂、模块越多，vite的优势越明显。
在HMR方面，当改动了一个模块后，仅需让浏览器重新请求该模块即可，不像webpack那样需要把该模块的相关依赖模块全部编译一次，效率更高。
当需要打包到生产环境时，vite使用传统的rollup进行打包，因此，vite的主要优势在开发阶段。另外，由于vite利用的是ESModule，因此在代码中不可以使用CommonJS

# Webpack

## webpack scope hoisting
webpack作用域优化

scopehoisting是webpack的内置优化，它是针对模块的优化。在生产环境打包时会自动开启。
在未开启scopehoisting时，webpack会将每个模块的代码放置在一个独立的函数环境中，这样是为了保证模块的作用域互不干扰。
scope hoisting的作用恰恰相反是把多个模块的代码合并到一个函数环境中执行。在这一过程中，webpack会按照顺序正确的合并模块代码，同时对涉及的标识符做适当处理以避免重名。
这样做的好处是减少了函数调用，对运行效率有一定提升，同时也降低了打包体积。
但scope hoisting的启用是有前提的，如果遇到某些模块多次被其他模块引用，或者使用了动态导入的模块，或者是非ESM的模块，都不会有scopehoisting。

## 模块联邦
用于解决微前端，不同模块之间代码复用问题
在webpack5提出的，是webpack的一个插件：ModuleFederationPlugin

# npm安装机制
1. npm会检查本地的node_modules目录中是否已经安装过该模块，如果已经安装，则不再重新安装
2. npm检查缓存中是否有相同的模块，如果有，直接从缓存中读取安装
3. 如果本地和缓存中均不存在，npm会从registry指定的地址下载安装包，然后将其写入到本地的node_modules目录中，同时缓存起来。

# CommonJS模块化实现原理
根据文件路径，找到模块文件，读取文件内容进行执行
1. 为了保证高效的执行，仅加载必要的模块，node只有再执行到require函数是才会加载并执行模块
2. 为了隐藏模块中的代码，node执行模块的时候会放到一个立即执行函数中执行，保证不污染全局变量
3. 为了保证顺利的导出模块内容，nodejs做了以下处理：
在模块开始执行前，初始化一个值module.exports={}，module.exports即模块的导出值。为了方便开发者便捷的导出，Codejs在初始化完module.exports后，又声明了一个变量exports=module.exports
```js
(function(module){
	module.exports={}
	var exports=module.exports
	//模块中的代码
	return module.exports
})()
```
4. 为了避免反复加载同一个模块，nodejs默认开启了模块缓存，如果加载
的模块已经被加载过了，则会自动使用之前的导出结果

**缺点：**
CommonJS是同步的，必须要等到加载完文件并执行完代码后才能继续向后执行
由于node运行在本机上，因此读取是在磁盘上读取，速度较快，但换到浏览器环境就不一样了，在浏览器中运行需要从网络上获取文件


